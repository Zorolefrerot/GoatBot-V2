
const fs = require('fs');

module.exports = {
  config: {
    name: "quizz",
    version: "1.0",
    author: "Merdi Madimba",
    countDown: 5,
    role: 0, // Seul l'admin peut lancer la commande
    shortDescription: "Quiz interactif avec diff√©rentes rubriques",
    longDescription: "Commande quiz avec choix de rubrique, mode duel ou g√©n√©ral, et questions chronom√©tr√©es",
    category: "game",
    guide: "{pn} - Lance un quiz interactif"
  },

  onStart: async function ({ message, event, threadsData }) {
    const threadData = await threadsData.get(event.threadID);
    
    // V√©rifier si un quiz est d√©j√† en cours
    if (global.GoatBot.quizData && global.GoatBot.quizData[event.threadID]) {
      return message.reply("‚ùå Un quiz est d√©j√† en cours dans ce groupe !");
    }

    // Initialiser les donn√©es du quiz
    if (!global.GoatBot.quizData) {
      global.GoatBot.quizData = {};
    }

    global.GoatBot.quizData[event.threadID] = {
      step: "category",
      admin: event.senderID,
      scores: {},
      currentQuestion: 0,
      questions: []
    };

    const categoryMessage = `üéØ **QUIZ INTERACTIF** üéØ
    
Choisissez votre rubrique :

üéå **manga** - Questions sur les mangas
üß† **culture g√©n√©rale** - Questions de culture g√©n√©rale

R√©pondez avec le nom de la rubrique que vous souhaitez !`;

    message.reply(categoryMessage, (err, info) => {
      global.GoatBot.onReply.set(info.messageID, {
        commandName: "quizz",
        messageID: info.messageID,
        author: event.senderID,
        step: "category"
      });
    });
  },

  onReply: async function ({ message, Reply, event, api }) {
    const { author, step } = Reply;
    const threadID = event.threadID;
    const quizData = global.GoatBot.quizData[threadID];

    if (!quizData || author !== event.senderID) {
      return;
    }

    if (step === "category") {
      const category = event.body.toLowerCase().trim();
      
      if (!["manga", "culture g√©n√©rale"].includes(category)) {
        return message.reply("‚ùå Rubrique invalide ! Choisissez entre **manga** ou **culture g√©n√©rale**");
      }

      quizData.category = category;
      quizData.step = "mode";

      const modeMessage = `üìù Rubrique s√©lectionn√©e : **${category}**

Choisissez le mode de jeu :

‚öîÔ∏è **duel** - Affrontement entre 2 joueurs sp√©cifiques
üåç **g√©n√©ral** - Quiz ouvert √† tous les membres

R√©pondez avec **duel** ou **g√©n√©ral** !`;

      message.reply(modeMessage, (err, info) => {
        global.GoatBot.onReply.set(info.messageID, {
          commandName: "quizz",
          messageID: info.messageID,
          author: event.senderID,
          step: "mode"
        });
      });

    } else if (step === "mode") {
      const mode = event.body.toLowerCase().trim();
      
      if (!["duel", "g√©n√©ral"].includes(mode)) {
        return message.reply("‚ùå Mode invalide ! Choisissez entre **duel** ou **g√©n√©ral**");
      }

      quizData.mode = mode;

      if (mode === "duel") {
        quizData.step = "duelists";
        const duelMessage = `‚öîÔ∏è **MODE DUEL S√âLECTIONN√â**

Veuillez entrer les UIDs des deux duellistes s√©par√©s par un espace.
Format : UID1 UID2

Exemple : 123456789 987654321`;

        message.reply(duelMessage, (err, info) => {
          global.GoatBot.onReply.set(info.messageID, {
            commandName: "quizz",
            messageID: info.messageID,
            author: event.senderID,
            step: "duelists"
          });
        });
      } else {
        quizData.step = "questions";
        const questionsMessage = `üåç **MODE G√âN√âRAL S√âLECTIONN√â**

Choisissez le nombre de questions :

**10** - Quiz rapide
**20** - Quiz moyen  
**30** - Quiz long
**50** - Quiz expert

R√©pondez avec le nombre souhait√© !`;

        message.reply(questionsMessage, (err, info) => {
          global.GoatBot.onReply.set(info.messageID, {
            commandName: "quizz",
            messageID: info.messageID,
            author: event.senderID,
            step: "questions"
          });
        });
      }

    } else if (step === "duelists") {
      const uids = event.body.trim().split(" ");
      
      if (uids.length !== 2 || !uids.every(uid => /^\d+$/.test(uid))) {
        return message.reply("‚ùå Format invalide ! Entrez exactement 2 UIDs s√©par√©s par un espace.");
      }

      quizData.duelists = uids;
      quizData.step = "questions";

      const questionsMessage = `‚öîÔ∏è **DUELLISTES S√âLECTIONN√âS**

Choisissez le nombre de questions pour le duel :

Entrez un nombre entre 5 et 20 questions.`;

      message.reply(questionsMessage, (err, info) => {
        global.GoatBot.onReply.set(info.messageID, {
          commandName: "quizz",
          messageID: info.messageID,
          author: event.senderID,
          step: "questions"
        });
      });

    } else if (step === "questions") {
      let numQuestions;
      
      if (quizData.mode === "g√©n√©ral") {
        numQuestions = parseInt(event.body.trim());
        if (![10, 20, 30, 50].includes(numQuestions)) {
          return message.reply("‚ùå Nombre invalide ! Choisissez 10, 20, 30 ou 50 questions.");
        }
      } else {
        numQuestions = parseInt(event.body.trim());
        if (numQuestions < 5 || numQuestions > 20) {
          return message.reply("‚ùå Pour un duel, choisissez entre 5 et 20 questions.");
        }
      }

      // Charger les questions
      await this.loadQuestions(quizData, numQuestions);
      
      if (quizData.questions.length === 0) {
        delete global.GoatBot.quizData[threadID];
        return message.reply("‚ùå Erreur lors du chargement des questions.");
      }

      // Commencer le quiz
      this.startQuiz(threadID, message, api);
    }
  },

  async loadQuestions(quizData, numQuestions) {
    try {
      const fileName = quizData.category === "manga" ? "manga_questions.json" : "culture_generale_questions.json";
      
      if (!fs.existsSync(fileName)) {
        console.error(`Fichier ${fileName} non trouv√©`);
        return;
      }

      const data = JSON.parse(fs.readFileSync(fileName, 'utf8'));
      const allQuestions = data.questions;
      
      // M√©langer et s√©lectionner le nombre de questions demand√©
      const shuffled = allQuestions.sort(() => 0.5 - Math.random());
      quizData.questions = shuffled.slice(0, Math.min(numQuestions, allQuestions.length));
      quizData.totalQuestions = quizData.questions.length;
      
    } catch (error) {
      console.error("Erreur lors du chargement des questions:", error);
    }
  },

  startQuiz(threadID, message, api) {
    const quizData = global.GoatBot.quizData[threadID];
    
    if (!quizData || quizData.questions.length === 0) {
      return;
    }

    const startMessage = `üéâ **QUIZ COMMENC√â !** üéâ

üìã **Rubrique :** ${quizData.category}
üéÆ **Mode :** ${quizData.mode}
‚ùì **Questions :** ${quizData.totalQuestions}
${quizData.duelists ? `‚öîÔ∏è **Duellistes :** ${quizData.duelists.join(" vs ")}` : ""}

‚è∞ **10 secondes par question**
üèÜ **10 points par bonne r√©ponse**

Le quiz commence dans 3 secondes...`;

    message.reply(startMessage);

    setTimeout(() => {
      this.askQuestion(threadID, message, api);
    }, 3000);
  },

  askQuestion(threadID, message, api) {
    const quizData = global.GoatBot.quizData[threadID];
    
    if (!quizData || quizData.currentQuestion >= quizData.questions.length) {
      return this.endQuiz(threadID, message, api);
    }

    const question = quizData.questions[quizData.currentQuestion];
    quizData.waitingForAnswer = true;
    quizData.answered = false;

    const questionMessage = `‚ùì **Question ${quizData.currentQuestion + 1}/${quizData.totalQuestions}**

${question.question}

‚è∞ Vous avez 10 secondes pour r√©pondre !`;

    message.reply(questionMessage, (err, info) => {
      global.GoatBot.onReply.set(info.messageID, {
        commandName: "quizz",
        messageID: info.messageID,
        step: "answer",
        questionIndex: quizData.currentQuestion
      });

      // Timer de 10 secondes
      setTimeout(() => {
        if (quizData.waitingForAnswer && !quizData.answered) {
          quizData.waitingForAnswer = false;
          api.unsendMessage(info.messageID);
          global.GoatBot.onReply.delete(info.messageID);
          
          const timeoutMessage = `‚è∞ **TEMPS √âCOUL√â !**

La bonne r√©ponse √©tait : **${question.answer}**

Question suivante dans 2 secondes...`;
          
          message.reply(timeoutMessage);
          
          quizData.currentQuestion++;
          setTimeout(() => {
            this.askQuestion(threadID, message, api);
          }, 2000);
        }
      }, 10000);
    });
  },

  async handleAnswer(event, message, api, usersData) {
    const threadID = event.threadID;
    const quizData = global.GoatBot.quizData[threadID];
    
    if (!quizData || !quizData.waitingForAnswer || quizData.answered) {
      return;
    }

    // V√©rifier si c'est un duel et si l'utilisateur peut r√©pondre
    if (quizData.mode === "duel" && !quizData.duelists.includes(event.senderID)) {
      return;
    }

    const question = quizData.questions[quizData.currentQuestion];
    const userAnswer = event.body.toLowerCase().trim();
    const correctAnswer = question.answer.toLowerCase().trim();

    if (userAnswer === correctAnswer) {
      quizData.answered = true;
      quizData.waitingForAnswer = false;

      // Ajouter les points
      if (!quizData.scores[event.senderID]) {
        quizData.scores[event.senderID] = { name: "", points: 0 };
      }
      
      const userData = await usersData.get(event.senderID);
      quizData.scores[event.senderID].name = userData.name;
      quizData.scores[event.senderID].points += 10;

      // Afficher le tableau des scores
      const scoreBoard = this.generateScoreBoard(quizData);
      
      const correctMessage = `‚úÖ **BONNE R√âPONSE !** 

üéâ **${userData.name}** a trouv√© la bonne r√©ponse : **${question.answer}**

${scoreBoard}

Question suivante dans 2 secondes...`;

      message.reply(correctMessage);

      quizData.currentQuestion++;
      setTimeout(() => {
        this.askQuestion(threadID, message, api);
      }, 2000);
    }
  },

  generateScoreBoard(quizData) {
    if (Object.keys(quizData.scores).length === 0) {
      return "üìä **TABLEAU DES SCORES**\n\nAucun point pour le moment...";
    }

    const sortedScores = Object.values(quizData.scores)
      .sort((a, b) => b.points - a.points);

    let scoreBoard = "üìä **TABLEAU DES SCORES**\n\n";
    
    sortedScores.forEach((player, index) => {
      const position = index === 0 ? "ü•á" : index === 1 ? "ü•à" : index === 2 ? "ü•â" : `${index + 1}.`;
      scoreBoard += `${position} **${player.name}** - ${player.points} pts\n`;
    });

    return scoreBoard;
  },

  endQuiz(threadID, message, api) {
    const quizData = global.GoatBot.quizData[threadID];
    
    if (!quizData) return;

    const scoreBoard = this.generateScoreBoard(quizData);
    const winner = Object.values(quizData.scores)
      .sort((a, b) => b.points - a.points)[0];

    let endMessage = `üéä **QUIZ TERMIN√â !** üéä

${scoreBoard}

`;

    if (winner) {
      endMessage += `üèÜ **VAINQUEUR : ${winner.name}** avec ${winner.points} points !

üéâ F√©licitations ! üéâ`;
    } else {
      endMessage += `üòÖ Aucun point marqu√© cette fois...
Meilleure chance la prochaine fois !`;
    }

    message.reply(endMessage);

    // Nettoyer les donn√©es
    delete global.GoatBot.quizData[threadID];
  },

  // Handler pour les r√©ponses pendant le quiz
  onReply: async function ({ message, Reply, event, api, usersData }) {
    if (Reply.step === "answer") {
      await this.handleAnswer(event, message, api, usersData);
    } else {
      // G√©rer les autres √©tapes (d√©j√† impl√©ment√© ci-dessus)
      return;
    }
  }
};
            
