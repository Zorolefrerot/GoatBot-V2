// 1xbet.js
const fs = require("fs");
const path = require("path");

// --- Fichiers ---
const dataFile = path.join(__dirname, "1xbet-data.json");
const matchesFile = path.join(__dirname, "1xbet-matches.json");
const teamsFile = path.join(__dirname, "teams.json");

// --- Init fichiers si besoin ---
if (!fs.existsSync(dataFile)) fs.writeFileSync(dataFile, JSON.stringify({}));
if (!fs.existsSync(matchesFile)) fs.writeFileSync(matchesFile, JSON.stringify([]));
if (!fs.existsSync(teamsFile)) throw new Error("teams.json introuvable. Cr√©e teams.json avant de lancer la commande.");

function loadData() { return JSON.parse(fs.readFileSync(dataFile)); }
function saveData(d) { fs.writeFileSync(dataFile, JSON.stringify(d, null, 2)); }

let matches = [];
try { matches = JSON.parse(fs.readFileSync(matchesFile)); } catch (e) { matches = []; }
function saveMatches() { fs.writeFileSync(matchesFile, JSON.stringify(matches, null, 2)); }

const teams = JSON.parse(fs.readFileSync(teamsFile));

// --- Constantes ---
const MIN_BET = 20;
const DAILY_AMOUNT = 200;
const WELCOME_IMAGE = "http://goatbiin.onrender.com/GBhPN2QYD.png"; // change si besoin

// --- Helpers ---
function rndInt(max) { return Math.floor(Math.random() * max); }
function pickTwoDistinct(availableTeams) {
  const i = rndInt(availableTeams.length);
  let j;
  do { j = rndInt(availableTeams.length); } while (j === i);
  return [availableTeams[i], availableTeams[j]];
}

// Calcul des cotes √† partir des forces -> stock√©es dans la structure du match
function computeOdds(teamA, teamB) {
  const drawBase = 0.12; // probabilit√© de nul de base
  const total = teamA.strength + teamB.strength;
  const probA = (teamA.strength / total) * (1 - drawBase);
  const probB = (teamB.strength / total) * (1 - drawBase);
  const probN = drawBase;

  // l√©ger facteur al√©atoire pour variation
  const rA = 0.9 + Math.random() * 0.3;
  const rB = 0.9 + Math.random() * 0.3;
  const rN = 0.95 + Math.random() * 0.2;

  return {
    A: Number((1 / probA * rA).toFixed(2)),
    N: Number((1 / probN * rN).toFixed(2)),
    B: Number((1 / probB * rB).toFixed(2))
  };
}

// G√©n√©re un score al√©atoire plausbile selon le r√©sultat
function randomScore(result) {
  if (result === "A") return `${Math.floor(Math.random() * 3) + 1}-${Math.floor(Math.random() * 3)}`;
  if (result === "B") return `${Math.floor(Math.random() * 3)}-${Math.floor(Math.random() * 3) + 1}`;
  // nul
  return `${Math.floor(Math.random() * 3)}-${Math.floor(Math.random() * 3)}`;
}

// R√©solution bas√©e sur les forces (probabilit√©s)
function pickResultByStrength(match) {
  const total = match.teamA.strength + match.teamB.strength;
  const drawBase = 0.12;
  const probA = (match.teamA.strength / total) * (1 - drawBase);
  const probB = (match.teamB.strength / total) * (1 - drawBase);
  const probN = drawBase;

  const r = Math.random();
  if (r < probN) return "N";
  if (r < probN + probA) return "A";
  return "B";
}

// --- Cr√©ation & scheduling des matchs ---
let nextMatchId = matches.reduce((m, x) => Math.max(m, x.id || 0), 0) + 1;

function scheduleResolve(match) {
  // clear √©ventuel timer
  if (match._timer) clearTimeout(match._timer);
  const delay = Math.max(0, (match.resolveAt || (Date.now() + 30000)) - Date.now());
  match._timer = setTimeout(() => resolveMatchRoutine(match.id), delay);
}

// Cr√©e n matchs al√©atoires et planifie leur r√©solution
function createMatches(originThreadID, n = 5, resolveInMs = 30000) {
  // on peut √©viter l'utilisation r√©p√©t√©e des m√™mes √©quipes dans le m√™me batch si tu veux
  for (let i = 0; i < n; i++) {
    const [A, B] = pickTwoDistinct(teams);
    const odds = computeOdds(A, B);
    const match = {
      id: nextMatchId++,
      teamA: A,
      teamB: B,
      odds,
      status: "open",
      bets: [],
      createdInThread: originThreadID,
      createdAt: Date.now(),
      resolveAt: Date.now() + resolveInMs
    };
    matches.push(match);
    scheduleResolve(match);
  }
  saveMatches();
}

// R√©solution centrale d'un match : distribue gains/pertes et notifie
function resolveMatchRoutine(matchId) {
  // Lire donn√©es fra√Æches
  matches = JSON.parse(fs.readFileSync(matchesFile));
  const data = JSON.parse(fs.readFileSync(dataFile));

  const matchIndex = matches.findIndex(m => m.id === matchId);
  if (matchIndex === -1) return;
  const match = matches[matchIndex];

  if (match.status !== "open") return; // d√©j√† r√©solu

  // D√©terminer r√©sultat selon forces
  const result = pickResultByStrength(match); // "A" | "B" | "N"
  const score = randomScore(result);
  match.status = "finished";
  match.result = result;
  match.score = score;

  // Pour chaque pari -> gains si choix === result
  for (const bet of match.bets) {
    const uid = bet.user;
    if (!data[uid]) {
      // utilisateur manquant, ignore
      continue;
    }
    // bet.odds a √©t√© enregistr√© au moment du pari (match.odds[choice])
    if (bet.choice === result) {
      const gain = Math.floor(bet.amount * bet.odds); // montant * cote
      data[uid].money = (data[uid].money || 0) + gain;
      // marquer l'historique
      if (!data[uid].bets) data[uid].bets = [];
      data[uid].bets.push({
        matchID: match.id,
        choice: bet.choice,
        amount: bet.amount,
        odds: bet.odds,
        status: "win",
        gain,
        resolvedAt: Date.now(),
        score
      });
      // annonce individuelle dans le thread du pari
      try { global.api.sendMessage(`üéâ ${data[uid].name || 'Joueur'}, TU AS GAGN√â ${gain}$ !\nüìä R√©sultat : ${match.teamA.name} ${score} ${match.teamB.name}`, bet.threadID); } catch(e) {}
    } else {
      // perdant (a d√©j√† √©t√© d√©bit√© √† la mise)
      if (!data[uid].bets) data[uid].bets = [];
      data[uid].bets.push({
        matchID: match.id,
        choice: bet.choice,
        amount: bet.amount,
        odds: bet.odds,
        status: "lose",
        gain: 0,
        resolvedAt: Date.now(),
        score
      });
      try { global.api.sendMessage(`üí• ${data[uid].name || 'Joueur'}, TU AS PERDU ta mise de ${bet.amount}$.\nüìä R√©sultat : ${match.teamA.name} ${score} ${match.teamB.name}`, bet.threadID); } catch(e) {}
    }
  }

  // Annonce g√©n√©rale dans le thread o√π les matchs ont √©t√© cr√©√©s (si connu)
  const announceThread = match.createdInThread;
  try {
    const text = `üèÅ Match ${match.id} termin√© : ${match.teamA.name} ${match.score} ${match.teamB.name} ‚Äî R√©sultat: ${result === "A" ? match.teamA.name : result === "B" ? match.teamB.name : "Nul"}\n\n‚ö†Ô∏è Les gains ont √©t√© distribu√©s aux gagnants.`;
    if (announceThread) global.api.sendMessage(text, announceThread);
  } catch (e) { /* ignore */ }

  // sauvegarde
  saveMatches();
  saveData(data);

  // Si plus aucun match 'open' -> cr√©er automatiquement 5 nouveaux matchs et annoncer
  const openCount = matches.filter(m => m.status === "open").length;
  if (openCount === 0) {
    // create 5 new matches in same thread to continue service
    createMatches(announceThread || match.createdInThread || match.bets?.[0]?.threadID || null, 5, 30000);
    // annoncer la cr√©ation
    try {
      const threadToAnnounce = announceThread || (match.bets && match.bets[0] && match.bets[0].threadID) || null;
      if (threadToAnnounce) {
        const upcoming = matches.slice(-5).map(m => `‚Ä¢ ${m.id}. ${m.teamA.name} vs ${m.teamB.name} ‚Äî üÖ∞Ô∏è ${m.odds.A} | üü∞ ${m.odds.N} | üÖ±Ô∏è ${m.odds.B}`).join("\n");
        global.api.sendMessage(`üîÑ Tous les matchs sont termin√©s ‚Äî 5 nouveaux matchs ont √©t√© cr√©√©s :\n\n${upcoming}`, threadToAnnounce);
      }
    } catch (e) { /* ignore */ }
  }
}

// Schedule les timers existants au d√©marrage (pour persistance)
(function scheduleExisting() {
  try {
    matches.forEach(m => {
      if (m.status === "open") scheduleResolve(m);
    });
  } catch (e) { /* ignore */ }
})();

// --- Commande principale export√©e pour GoatBot ---
module.exports = {
  config: {
    name: "1xbet",
    aliases: ["bet", "betmatch"],
    version: "5.0",
    author: "Merdi Madimba",
    role: 0,
    description: "Simulation de paris sur les matchs ‚öΩ",
    category: "üéÆ Jeux"
  },

  onStart: async function ({ api, event, args }) {
    // expose api globalement pour que resolveMatchRoutine puisse l'utiliser
    global.api = api;

    const { threadID, senderID, messageID } = event;
    const data = loadData();
    if (!data[senderID]) data[senderID] = { money: 0, lastDaily: 0, name: `Joueur-${senderID}`, bets: [] };
    const user = data[senderID];
    const sub = args[0] ? args[0].toLowerCase() : null;

    // --- Accueil ---
    if (!sub) {
      const body = `üèüÔ∏è **1XBET (simulation)** ‚öΩ

Commandes :
‚Ä¢ /1xbet matches ‚Üí Voir les matchs disponibles
‚Ä¢ /1xbet bet [matchID] [A|N|B] [montant] ‚Üí Parier (mise min ${MIN_BET}$)
‚Ä¢ /1xbet mybets ‚Üí Voir tes paris (dernier 10)
‚Ä¢ /1xbet solde ‚Üí Voir ton solde
‚Ä¢ /1xbet daily ‚Üí Bonus quotidien ${DAILY_AMOUNT}$
‚Ä¢ /1xbet top ‚Üí Top 10 des joueurs

üÖ∞Ô∏è = √©quipe 1 gagne | üü∞ = match nul | üÖ±Ô∏è = √©quipe 2 gagne`;

      try {
        const stream = await global.utils.getStreamFromURL(WELCOME_IMAGE);
        return api.sendMessage({ body, attachment: stream }, threadID, messageID);
      } catch (e) {
        return api.sendMessage(body, threadID, messageID);
      }
    }

    // --- solde ---
    if (sub === "solde") {
      return api.sendMessage(`üí∞ ${user.name}, ton solde : ${user.money}$`, threadID, messageID);
    }

    // --- daily ---
    if (sub === "daily") {
      const now = Date.now();
      if (now - (user.lastDaily || 0) < 24 * 60 * 60 * 1000) {
        const remain = Math.ceil((24 * 60 * 60 * 1000 - (now - user.lastDaily)) / (1000 * 60 * 60));
        return api.sendMessage(`üïí D√©j√† pris. Reviens dans ${remain}h.`, threadID, messageID);
      }
      user.money += DAILY_AMOUNT;
      user.lastDaily = now;
      saveData(data);
      return api.sendMessage(`‚úÖ Bonus ${DAILY_AMOUNT}$ ajout√©. Nouveau solde : ${user.money}$`, threadID, messageID);
    }

    // --- matches ---
    if (sub === "matches") {
      // Si moins de 5 matchs ouverts -> cr√©er pour arriver √† 5
      const openMatches = matches.filter(m => m.status === "open");
      if (openMatches.length < 5) {
        const toCreate = 5 - openMatches.length;
        createMatches(threadID, toCreate, 30000); // resolve in 30s
      }

      // recharger matches
      matches = JSON.parse(fs.readFileSync(matchesFile));
      const list = matches
        .filter(m => m.status === "open")
        .map(m => `üèÅ Match ${m.id}
‚öΩ ${m.teamA.name} üÜö ${m.teamB.name}
üí™ Force : ${m.teamA.strength} - ${m.teamB.strength}
üìà C√¥tes : üÖ∞Ô∏è ${m.odds.A} | üü∞ ${m.odds.N} | üÖ±Ô∏è ${m.odds.B}
‚è± R√©solution dans : ${Math.max(0, Math.ceil((m.resolveAt - Date.now()) / 1000))}s`)
        .join("\n\n");

      if (!list) return api.sendMessage("‚ÑπÔ∏è Aucun match ouvert pour le moment, cr√©ation en cours...", threadID, messageID);
      return api.sendMessage(`üìã **Matchs disponibles :**\n\n${list}`, threadID, messageID);
    }

    // --- bet ---
    if (sub === "bet") {
      // format: /1xbet bet [matchID] [A|N|B] [amount]
      const matchID = parseInt(args[1]);
      const choice = args[2] ? args[2].toUpperCase() : null;
      const amount = parseInt(args[3]);

      if (!matchID || !choice || isNaN(amount)) {
        return api.sendMessage(`‚ö†Ô∏è Format invalide.\nEx: /1xbet bet 2 A 100`, threadID, messageID);
      }
      if (!["A", "B", "N"].includes(choice)) return api.sendMessage("‚ö†Ô∏è Choix invalide. Utilise A, N ou B.", threadID, messageID);
      if (amount < MIN_BET) return api.sendMessage(`üíµ Mise minimale : ${MIN_BET}$`, threadID, messageID);

      // reload matches & data fresh
      matches = JSON.parse(fs.readFileSync(matchesFile));
      const match = matches.find(m => m.id === matchID);
      if (!match) return api.sendMessage(`‚ùå Match ${matchID} introuvable.`, threadID, messageID);
      if (match.status !== "open") return api.sendMessage("üö´ Ce match n'est plus ouvert aux paris.", threadID, messageID);
      if (user.money < amount) return api.sendMessage("‚ùå Solde insuffisant.", threadID, messageID);

      // Retirer la mise du user imm√©diatement
      user.money -= amount;

      // Stocker le pari dans le match et dans l'historique utilisateur (pending)
      const bet = { user: senderID, choice, amount, odds: match.odds[choice], threadID };
      match.bets.push(bet);

      if (!user.bets) user.bets = [];
      user.bets.push({ matchID: match.id, choice, amount, odds: match.odds[choice], status: "pending", placedAt: Date.now() });

      saveData(data);
      saveMatches();

      // informer utilisateur
      api.sendMessage(`‚úÖ Pari plac√© sur Match ${match.id} : ${match.teamA.name} vs ${match.teamB.name}
Choix: ${choice} | Mise: ${amount}$ | Cote: ${match.odds[choice]}
‚åõ R√©sultat dans ~30s.`, threadID, messageID);

      return;
    }

    // --- mybets ---
    if (sub === "mybets") {
      if (!user.bets || user.bets.length === 0) return api.sendMessage("üì≠ Tu n'as aucun pari pour l'instant.", threadID, messageID);
      const list = user.bets.slice(-10).reverse().map(b => {
        const m = matches.find(x => x.id === b.matchID);
        const teamsText = m ? `${m.teamA.name} vs ${m.teamB.name}` : "Match supprim√©";
        const status = b.status === "pending" ? "‚è≥ En attente" : b.status === "win" ? "‚úÖ Gagn√©" : "‚ùå Perdu";
        const score = b.resolvedAt ? (m && m.score ? ` | Score: ${m.score}` : "") : "";
        return `üéØ Match ${b.matchID} ‚Äî ${teamsText}
Choix: ${b.choice} | Mise: ${b.amount}$ | Cote: ${b.odds} | Statut: ${status}${score}`;
      }).join("\n\n");
      return api.sendMessage(`üìã Tes 10 derniers paris :\n\n${list}`, threadID, messageID);
    }

    // --- top ---
    if (sub === "top") {
      const data = loadData();
      const top = Object.entries(data).map(([uid, u]) => ({ name: u.name || uid, money: u.money || 0 }))
        .sort((a, b) => b.money - a.money).slice(0, 10);
      const text = top.map((t, i) => `${i + 1}. ${t.name} ‚Äî ${t.money}$`).join("\n");
      return api.sendMessage(`üèÜ Top 10 :\n\n${text}`, threadID, messageID);
    }

    // fallback
    return api.sendMessage("Commande inconnue. Tape /1xbet pour l'aide.", threadID, messageID);
  }
};
